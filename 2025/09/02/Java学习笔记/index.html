<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java学习笔记 | Ciallo～(∠・ω&lt; )⌒☆</title><meta name="author" content="Fire King"><meta name="copyright" content="Fire King"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="DOS命令win的相关DOS命令Window呼出dos窗口的方式：win+R–cmd exit-退出当前DOS命令窗口 cls-清屏 dir-列出当前目录下所有子文件&#x2F;子目录 cd 路径-进入路径*绝对路径：表示该路径从某个磁盘的盘符下作为出发点*相对路径：表示该路径从当前所在路径下作为出发点 cd ..-回到上级目录 cd -直接回到根目录 盘符:+回车-切换盘符 md 目录名-创建目">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习笔记">
<meta property="og:url" content="https://fire0king.github.io/2025/09/02/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Ciallo～(∠・ω&lt; )⌒☆">
<meta property="og:description" content="DOS命令win的相关DOS命令Window呼出dos窗口的方式：win+R–cmd exit-退出当前DOS命令窗口 cls-清屏 dir-列出当前目录下所有子文件&#x2F;子目录 cd 路径-进入路径*绝对路径：表示该路径从某个磁盘的盘符下作为出发点*相对路径：表示该路径从当前所在路径下作为出发点 cd ..-回到上级目录 cd -直接回到根目录 盘符:+回车-切换盘符 md 目录名-创建目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fire0king.github.io/img/github_icon.jpg">
<meta property="article:published_time" content="2025-09-02T05:55:12.000Z">
<meta property="article:modified_time" content="2025-09-02T15:10:49.224Z">
<meta property="article:author" content="Fire King">
<meta property="article:tag" content="java">
<meta property="article:tag" content="dos">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fire0king.github.io/img/github_icon.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java学习笔记",
  "url": "https://fire0king.github.io/2025/09/02/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
  "image": "https://fire0king.github.io/img/github_icon.jpg",
  "datePublished": "2025-09-02T05:55:12.000Z",
  "dateModified": "2025-09-02T15:10:49.224Z",
  "author": [
    {
      "@type": "Person",
      "name": "Fire King",
      "url": "https://fire0king.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://fire0king.github.io/2025/09/02/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/heimu.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/firefly1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Ciallo～(∠・ω&lt; )⌒☆</span></a><a class="nav-page-title" href="/"><span class="site-name">Java学习笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-02T05:55:12.000Z" title="发表于 2025-09-02 13:55:12">2025-09-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-02T15:10:49.224Z" title="更新于 2025-09-02 23:10:49">2025-09-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="DOS命令"><a href="#DOS命令" class="headerlink" title="DOS命令"></a>DOS命令</h1><h2 id="win的相关DOS命令"><a href="#win的相关DOS命令" class="headerlink" title="win的相关DOS命令"></a>win的相关DOS命令</h2><p>Window呼出dos窗口的方式：win+R–cmd</p>
<p>exit-退出当前DOS命令窗口</p>
<p>cls-清屏</p>
<p>dir-列出当前目录下所有子文件&#x2F;子目录</p>
<p>cd 路径-进入路径<br>*绝对路径：表示该路径从某个磁盘的盘符下作为出发点<br>*相对路径：表示该路径从当前所在路径下作为出发点</p>
<p>cd ..-回到上级目录</p>
<p>cd -直接回到根目录</p>
<p>盘符:+回车-切换盘符</p>
<p>md 目录名-创建目录</p>
<p>rd 目录名-删除目录</p>
<p>del 文件名-删除文件</p>
<h2 id="JDK的DOS命令"><a href="#JDK的DOS命令" class="headerlink" title="JDK的DOS命令:"></a>JDK的DOS命令:</h2><p>javac java源文件路径-编译java文件<br>*如果生成clss后其对应java源文件删除并不会影响其运行，但是一般并不会删除源文件<br>*编译结束后可将class文件拷贝的其他操作系统中运行（跨平台）</p>
<p>java 类名-运行类文件</p>
<p>相关术语：</p>
<p>xxx.class被称为一个类，xxx叫做类名</p>
<p>JDK：java编译器（开发器）<br>JVM：java虚拟机（跨平台用）<br>JER：java运行器（程序运行器）</p>
<p>API文档：java语言自带的说明书</p>
<h1 id="java语言："><a href="#java语言：" class="headerlink" title="java语言："></a>java语言：</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>&#x2F;&#x2F;注释内容-单行注释</p>
<p>&#x2F;<em>注释内容</em>&#x2F;-多行注释</p>
<p>&#x2F;*<em>注释内容</em>&#x2F;-文档注释<br>*使用方法：dos中使用命令：javadoc   可以生成一套以网页文件形式体现的该程序的说明文档</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字：int , byte , double , public 等</p>
<p>​	 特点：关键字所有的字母都是小写</p>
<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p>保留字-现有java版本未使用，但在以后版本会使用，自己命名标识符时应避开</p>
<p>如： goto 等</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符：对各种变量，方法，类等要素命名时使用的字符序列（凡是自己可以起名的地方都叫标识符）</p>
<h3 id="规则："><a href="#规则：" class="headerlink" title="*规则："></a>*规则：</h3><p>由26个英文字母大小写，0-9，_或$组成<br>数字不可以开头<br>不可以使用关键字和保留字，但能包含关键字和保留字<br>java中严格区分大小写，长度无限制<br>标识符不能包含空格</p>
<h3 id="规范"><a href="#规范" class="headerlink" title="*规范"></a>*规范</h3><p>xxxyyyzzz	包名：多单词组成时，所用字母都小写<br>XxxYyyZzz	类名、接口名：多单词组成时，所有单词的首字母大写<br>xxxYyyZzz	变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写<br>XXX_YYY_ZZZ	常量名：所有字母都大写，多单词时每个单词用下划线连接</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="*注意"></a>*注意</h3><p>起名时，尽量做到“见名知意”，以提高阅读性<br>java采用unicode字符集，因此标识符可以使用汉字，但是不建议使用！（正经人谁这样写代码）</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量：内存中的一个存储区域，其数据可以在同一类型范围内不断变化<br>        变量是程序中最基本的存储单元，由：变量类型（字符序列）、变量名、存储的值  三部分组成<br>        变量的作用是用于在内存中保存数据</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="*注意："></a>*注意：</h2><p>java中每个变量必须先声明，后使用<br>使用变量名来访问这块区域的数据<br>变量的作用域：其定义所在的一对{}内<br>变量只有在其作用域才有效<br>同一作用域不能定义重名的变量</p>
<h1 id="java定义变量的格式："><a href="#java定义变量的格式：" class="headerlink" title="java定义变量的格式："></a>java定义变量的格式：</h1><p>​	 数据类型 变量名 &#x3D; 变量值;<br>​	或者：   数据类型 变量名&#x2F;&#x2F;变量的声明<br>​			变量名 &#x3D; 变量值&#x2F;&#x2F;变量的赋值</p>
<h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="*数据类型："></a>*数据类型：</h4><h4 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h4><h5 id="数值型："><a href="#数值型：" class="headerlink" title="数值型："></a>数值型：</h5><p>​			整型-byte（1字节&#x3D;8bit）,short（2字节）,int（4字节）,long（8字节）    （存储内存从小到大）</p>
<p>​			 声明long型变量（即赋变量值）末尾必须以大写L或小写l作为结尾		常用int</p>
<p>​			 byte范围：-128 ~ 127</p>
<p>​			 浮点型-float（4字节）,double（8字节）          （存储内存从小到大）即：带小数点的数值（赋值时必须带小数点）    </p>
<p>​			 声明float型变量（即赋变量值）末尾必须以大写F或小写f作为结尾    常用double	</p>
<h5 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h5><p>​		字符型-char（1字符&#x3D;2字节）     定义char型变量（赋值时）通常使用一对’’   单引号内部只能写一个字符<br>​					表示方式：1.声明一个字符（必须有且只有一个字符） 2.转义字符：\b-退格符  \n-换行符  \r-回车符  \t-制表符（Tab键作用）  &quot;-双引号  &#39;-单引号  \-反斜线（拒绝转义字符转义第一个\以后的意义） 3.直接表示：直接用Unicode值来表示字符常量：\uXXXX(xxxx为16进制码)</p>
<h5 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h5><p>​		布尔型-boolean（只能取两个值之一：true&#x2F;false）     常在条件判断，循环结构使用</p>
<h4 id="基本数据类型之间的运算规则："><a href="#基本数据类型之间的运算规则：" class="headerlink" title="基本数据类型之间的运算规则："></a>基本数据类型之间的运算规则：</h4><p>前提：这里讨论的运算是不包含布尔型的</p>
<h5 id="1-自动类型提升："><a href="#1-自动类型提升：" class="headerlink" title="1.自动类型提升："></a>1.自动类型提升：</h5><p>​	① 当容量小的数据类型变量与容量大的数据类型变量做运算时，结果自动提升为容量大的数据类型<br>​	byte、char、short &gt; int &gt; long &gt; float &gt; double（容量从小到大）<br>​	② 特别的：当byte，char，short三种类型的变量做运算时，结果为int型</p>
<h5 id="2-强制类型转换："><a href="#2-强制类型转换：" class="headerlink" title="2.强制类型转换："></a>2.强制类型转换：</h5><p>​	自动类型提升运算的逆运算（截断操作，可能导致精度损失，不是四舍五入）<br>​	在赋值的变量值前加强转符：()，括号内填入强制转换的数值类型</p>
<pre><code>特别的：当你在需要加L在末尾时忘记加会使用默认的int（超出的部分数据丢失），但当未加F时会报错
        对于常量，整型常量默认int型，浮点型常量默认double型
</code></pre>
<p>说明：此处的容量大小指表示数的范围大小</p>
<pre><code>引用数据类型：
    类-class     （字符串在类中）
    接口-interface
    数组-array

    String属于引用数据类型，翻译为：字符串
    声明String类型变量时使用一对 &quot;&quot; 来赋值
    String可以和8种基本数据类型变量做运算，且运算只能是连接运算： + ，运算的结果仍然是String类型
</code></pre>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算数运算符："><a href="#算数运算符：" class="headerlink" title="算数运算符："></a>算数运算符：</h2><p>​	+正号、-负号、+加、-减、*乘、&#x2F;除、%取模（取余）、++自增（前）：先运算后取值，++自增（后）：先取值后运算、自减（前）：先运算后取值，自减（后）：先取值后运算、+字符串连接<br>​		&#x2F;的结果也是截断，数据计算在一半呢情况下是按照从左往右依次运算，可以使用强转符或自动数据类型提升来满足对整型到浮点型的转换<br>​		%的结果符号与被模数的符号相同，开发中经常使用%来判断能否被除尽的情况<br>​	（前）++ 先自增1，后运算（先加1）<br>​	（后）++ 先运算，后自增1（后加1）<br>​	（前）– 与前++类似<br>​	（后）– 与后++类似<br>​	注意：如果后加1则不影响运算，结果不需要再加1<br>​		如果一个变量在计算中有多次++，则其在每一次++中都会自增1，但是具体参与运算要看其前后位置<br>​		以及一个变量与++在一个小括号中时不影响其运算顺序，仍按照前后++区分具体情况<br>​	自增或自减运算不会改变本身的数据类型，而在常量中整数默认均为int，小数默认均为double</p>
<h2 id="赋值运算符："><a href="#赋值运算符：" class="headerlink" title="赋值运算符：&#x3D;"></a>赋值运算符：&#x3D;</h2><p>​	当“&#x3D;”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则处理<br>​	支持连续赋值：<br>​		如：int i1，j1;<br>​			i1 &#x3D; j1 &#x3D; 10;<br>​		或：int i2 &#x3D; 10，j2 &#x3D; 20;</p>
<pre><code>扩展赋值运算符：+=，-=，*=，/=，%=
    如：num += 2  等效于  num = num+2  ，但是+=不该变本身数据类型
</code></pre>
<p>比较运算符（关系运算符）：<br>    &#x3D;&#x3D;相等于 、 !&#x3D;不等于 、 &lt;小于 、 &gt;大于 、 &lt;&#x3D;小于等于 、 &gt;&#x3D;大于等于 、 instanceof检查是否是类的对象</p>
<pre><code>比较运算符的结果都是boolean型，也就是要么是true，要么是false
注意：==是等于号，=是赋值号，将等号右侧的数赋值给左侧
</code></pre>
<h2 id="逻辑运算符："><a href="#逻辑运算符：" class="headerlink" title="逻辑运算符："></a>逻辑运算符：</h2><p>​	&amp;逻辑与、 |逻辑或、 !逻辑非<br>​	&amp;&amp;短路与、||短路或、^逻辑异或<br>​	同集合的与，或，非，异或则为两者相同为false，两者不同为true<br>​	结果也都为布尔型</p>
<pre><code>逻辑运算符操作的都是布尔运算

区分&amp;与&amp;&amp;：
    相同点：&amp;与&amp;&amp;的运算结果相同
            当符号左边是true时，二者都会执行符号右边的运算
    不同点：当符号左边是false时，&amp;继续执行符号右边的运算，&amp;&amp;不再执行符号右边的运算
区分|与||：
    相同点：|与||的运算结果相同
            当符号左边是false时，二者都会执行符号右边的运算
    不同点：当符号左边是true时，|继续执行符号右边的运算，||不再执行符号右边的运算

开发中推荐使用短路与&amp;&amp;或短路或||
</code></pre>
<h2 id="位运算符（运用较少）"><a href="#位运算符（运用较少）" class="headerlink" title="位运算符（运用较少）"></a>位运算符（运用较少）</h2><p>​	&lt;&lt;左移、&gt;&gt;右移、&gt;&gt;&gt;无符号右移、&amp;与运算、|或运算、^异或运算、~取反运算<br>​	位运算符操作的都是整型的数据<br>​	&lt;&lt;：在一定范围内每向左移1位，相当于*2<br>​	&gt;&gt;：在一定范围内每向左移1位，相当于&#x2F;2</p>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>​	格式： (条件表达式)?表达式1:表达式2<br>​	条件表达式的结果为布尔型<br>​	根据条件表达式真或假决定执行表达式1还是2<br>​	如果是表达式为true，执行表达式1；如果表达式为false，执行表达式2<br>​	表达式1和2要求是一致的（也就是类型要相同）<br>​	三元运算符可以嵌套使用<br>​	*三元运算符的两个表达式必须类型相同，否则编译不通过或自动类型提升</p>
<pre><code>凡是可以用三元运算符的地方都可以改写为if-else，反之不成立
    格式 if()&#123;&#125;else&#123;&#125;
如果一个程序既可以使用三元又可以用if-else结构，优先选择三元，因为其更简洁，执行效率更高
</code></pre>
<p>在运算中区分 + 代表运算加法还是连接符：从左往右运算，若前运算中为String型，则为连接符，若为int等形式则为计算符</p>
<h2 id="运算符的优先级："><a href="#运算符的优先级：" class="headerlink" title="运算符的优先级："></a>运算符的优先级：</h2><p>挺杂的，不建议记忆，可通过下方法逃课<br>    先运算的加()，或者多行代码分步运算</p>
<p>*变量在类中声明的位置：–</p>
<h1 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h1><h2 id="if-else的三种结构"><a href="#if-else的三种结构" class="headerlink" title="if-else的三种结构"></a>if-else的三种结构</h2><p>​	if(条件表达式){执行代码块;}		如果不为true直接跳过执行代码<br>​	二选一：if(条件表达式){执行代码块1;}else{执行代码块2;}<br>​	多选一：if(条件表达式1){执行代码块1;}else if(条件表达式2){执行代码块2;}……else{执行代码块n;}<br>*else结构是可选的<br>*如果多个条件表达式之间是互斥关系（或没有交集关系），哪个判断和执行语句在上or下都可以；如果多个条件表达式之间有交集，应该考虑清楚应该将那个结构声明在上面</p>
<h2 id="switch-case格式"><a href="#switch-case格式" class="headerlink" title="switch-case格式"></a>switch-case格式</h2><p>​	switch(表达式){case 常量1:执行语句1;&#x2F;&#x2F;break;case 常量2:执行语句2;&#x2F;&#x2F;break;……常量n:执行语句n;&#x2F;&#x2F;break;default:执行语句;}   注：&#x2F;&#x2F;后的break可加可不加<br>*根据switch表达式中的值依次匹配各个case中的常量，一旦匹配成功（即&#x3D;&#x3D;时）则介入调用相应case结构中的执行语句<br>*当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构的末尾结束为止<br>*break可以使用在switch-case结构中，表示一旦执行到此关键字就跳出switch-case结构<br>*switch-case结构中的表达式只能是如下的6种类型之一：byte、short、char、int、枚举类型（JDK5.0新增）、String类型（JDK7.0新增）<br>*case之后只能声明常量，不能声明范围等<br>*break关键字是可选的，一般情况都需要加break<br>*default：相当于if-else结构中的else，和else一样也是可选的，default位置是灵活的（但是一般写最后）</p>
<p>凡是可以使用switch-case的结构，都可以转换为if-else，反之不成立<br>我们写分支结构时，当发现既可以使用switch-case（switch中表达式取值情况不太多），又可以使用if-else时，优先选择switch-case，因为switch-case的执行效率稍高</p>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="循环结构的4个要素："><a href="#循环结构的4个要素：" class="headerlink" title="循环结构的4个要素："></a>循环结构的4个要素：</h2><p>​	1.初始化条件  2.循环条件-只能是boolean类型  3.循环体  4.迭代条件</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>​		for循环的结构：   for(1;2;4){3}<br>​		执行过程：1 - 2(true) - 3 - 4 - 2(true) - 3 - 4 - … - 2(false)<br>​		*关于break关键字的使用：一旦在循环中执行到break，就跳出循环</p>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>​		while循环的结构：  ①; while(②){ ③; ④;}<br>​		执行过程：1 - 2(true) - 3 - 4 - 2(true) - 3 - 4 - … - 2(false)<br>​		*写while循环千万不要丢了迭代条件，一旦丢了可能导致死循环<br>        *for循环和while循环是可以相互转换的</p>
<h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h2><p>​		结构：①; do{ ③; ④;}while(②);<br>​		过程：1 - 3 - 4 - 2 - 3 - 4 - … - 2<br>​		*do-while循环至少会执行一次循环体</p>
<p>*循环也可以依靠break跳出，不一定非要用循环条件<br>*while(true)或for(;;)是最简单的不限制循环次数（既死循环）的写法（无break时）</p>
<h2 id="嵌套循环："><a href="#嵌套循环：" class="headerlink" title="嵌套循环："></a>嵌套循环：</h2><p>​	将一个循环结构A声明在另一个循环结构B的循环体中，就构成了嵌套循环<br>​	外层循环：循环结构B<br>​	内层循环：循环结构A</p>
<h2 id="break和continue关键字的使用"><a href="#break和continue关键字的使用" class="headerlink" title="break和continue关键字的使用"></a>break和continue关键字的使用</h2><p>​	break：switch-case，循环结构中   循环中使用的作用是结束当前循环   默认跳出包裹此关键字最近的一层循环<br>​	continue：循环结构中   循环中使用的作用是结束当次循环   默认跳出这次循环中包裹此关键字最近的一层循环<br>*在这两者关键字的后面不能直接声明执行语句（编译不通过）<br>*也可以通过标签来结束指定标识的一层循环结构（在循环关键字前加上label:（常用label或一个l）并且在break后加上此标签）<br>*return并非专门用于结束循环，，而是用于结束一个方法</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理</p>
<h2 id="数组的常见概念："><a href="#数组的常见概念：" class="headerlink" title="数组的常见概念："></a>数组的常见概念：</h2><h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><p>​	索引（或下标、角标）<br>​	元素<br>​	数组的长度：元素的个数</p>
<h3 id="数组的特点："><a href="#数组的特点：" class="headerlink" title="数组的特点："></a>数组的特点：</h3><p>​	数组是有序排列的<br>​	数组属于引用数据类型的变量，数组的元素可以是基本数据类型也可以是引用数据类型<br>​	数组在内存中会开辟连续的一整块空间，数组的长度一旦确定不能修改</p>
<h3 id="数组的分类："><a href="#数组的分类：" class="headerlink" title="数组的分类："></a>数组的分类：</h3><p>​	按照维数：一维数组、二维数组……<br>​	按照数组的元素类型：基本数据类型元素的数组、引用数据类型元素的数组</p>
<h2 id="一维数组的使用："><a href="#一维数组的使用：" class="headerlink" title="一维数组的使用："></a>一维数组的使用：</h2><h3 id="1-一维数组的声明和初始化"><a href="#1-一维数组的声明和初始化" class="headerlink" title="1.一维数组的声明和初始化"></a>1.一维数组的声明和初始化</h3><p>​		int[] ids;  声明<br>​		① ids &#x3D; new int[]{1001,1002,1003};  静态初始化：数组的初始化和数组元素的赋值操作同时进行<br>​		int[] arr &#x3D; {1001,1002,1003};   类型判断（这样写效果相同，但必须声明与初始化同时进行）<br>​		② String[] names &#x3D; new String[5];  动态初始化：数组的初始化和元素的赋值操作分开进行<br>​	总结：数组一旦初始化完成，其长度就确定了</p>
<h3 id="2-如何调用数组的指定位置的元素：通过索引的方式，数组的索引从0开始，到数组的长度-1结束"><a href="#2-如何调用数组的指定位置的元素：通过索引的方式，数组的索引从0开始，到数组的长度-1结束" class="headerlink" title="2.如何调用数组的指定位置的元素：通过索引的方式，数组的索引从0开始，到数组的长度-1结束"></a>2.如何调用数组的指定位置的元素：通过索引的方式，数组的索引从0开始，到数组的长度-1结束</h3><p>​	names[0] &#x3D; “张三”;<br>​	names[1] &#x3D; “李四”;<br>​	names[2] &#x3D; “王五”;<br>​	names[3] &#x3D; “小六”;<br>​	names[4] &#x3D; “老八”;</p>
<h3 id="3-如何获取数组的长度："><a href="#3-如何获取数组的长度：" class="headerlink" title="3.如何获取数组的长度："></a>3.如何获取数组的长度：</h3><p>​	属性：length</p>
<p>​	System.out.println(names.length);<br>​	System.out.println(ids.length);</p>
<h3 id="4-如何遍历数组"><a href="#4-如何遍历数组" class="headerlink" title="4.如何遍历数组"></a>4.如何遍历数组</h3><p>​	for(int i &#x3D; 0;i &lt; names.length;i ++)<br>​	{<br>​		System.out.println(names[i]);<br>​	}</p>
<h3 id="5-数组元素的默认初始化值"><a href="#5-数组元素的默认初始化值" class="headerlink" title="5.数组元素的默认初始化值"></a>5.数组元素的默认初始化值</h3><p>​	数组元素为整型，默认为：0<br>​	数组元素为浮点型，默认为：0.0<br>​	数组元素为char型，默认为：0或’\u0000’，而非’0’<br>​	数组元素为布尔型，默认为：false<br>​	数组元素为引用数据类型，默认为：null</p>
<pre><code>6.数组的内存解析--
</code></pre>
<h2 id="二维数组的使用："><a href="#二维数组的使用：" class="headerlink" title="二维数组的使用："></a>二维数组的使用：</h2><p>​	理解：一个一维数组作为另外一个一维数组的元素而存在（其实从数组底层运行机制来看，其实没有多维数组）	</p>
<h3 id="1-二维数组的声明和初始化"><a href="#1-二维数组的声明和初始化" class="headerlink" title="1.二维数组的声明和初始化"></a>1.二维数组的声明和初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[ ] [ ] arr1 = <span class="keyword">new</span> <span class="title class_">int</span> [ ] [ ]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;   <span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">int</span>[ ] [ ] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;  <span class="comment">//类型判断</span></span><br><span class="line">String[ ] [ ] arr2 = <span class="keyword">new</span> <span class="title class_">String</span> [<span class="number">3</span>] [<span class="number">2</span>];   <span class="comment">//动态初始化1</span></span><br><span class="line">String[ ] [ ] arr2 = <span class="keyword">new</span> <span class="title class_">String</span> [<span class="number">3</span>] [ ];   <span class="comment">//动态初始化2</span></span><br><span class="line"><span class="comment">//特别的：其实左侧的两个中括号无论哪个写在左侧方法名还是类名后面都可以起到相同作用，靠近左侧的方括号为外层元素，右侧为内层元素</span></span><br><span class="line"><span class="comment">//指针概念：在上方arr2中并没有指定元素数组中的元素，所以没有指针，运行会报错，可以通过下方方法引入指针</span></span><br><span class="line">arr3[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<h3 id="2-如何调用数组指定位置的元素"><a href="#2-如何调用数组指定位置的元素" class="headerlink" title="2.如何调用数组指定位置的元素"></a>2.如何调用数组指定位置的元素</h3><p>​		System.out.println(arr[0] [1]);</p>
<h3 id="3-如何获取数组的长度"><a href="#3-如何获取数组的长度" class="headerlink" title="3.如何获取数组的长度"></a>3.如何获取数组的长度</h3><p>​		System.out.println(arr.length);    &#x2F;&#x2F;外层<br>​		System.out.println(arr[0].length); &#x2F;&#x2F;内层</p>
<h3 id="4-如何遍历数组-1"><a href="#4-如何遍历数组-1" class="headerlink" title="4.如何遍历数组"></a>4.如何遍历数组</h3><p>​		for(int i &#x3D; 0;i &lt; arr.length;i++)<br>​		{<br>​			for(int j &#x3D; 0;j &lt; arr[i].length;j++)<br>​			{<br>​				System.out.print(arr[i][j] + “ “);<br>​			}<br>​			System.out.println();<br>​		}<br>​		&#x2F;&#x2F;二维数组遍历需要两层for循环，以此类推</p>
<h3 id="5-数组元素的默认初始化值-1"><a href="#5-数组元素的默认初始化值-1" class="headerlink" title="5.数组元素的默认初始化值"></a>5.数组元素的默认初始化值</h3><p>​		int[ ] [ ] arr &#x3D; new int[2] [3];<br>​		System.out.println(arr);&#x2F;&#x2F;[[I@XXXXXXXX（地址值）<br>​		System.out.println(arr[0]);&#x2F;&#x2F;[I@XXXXXXXX（地址值）<br>​		&#x2F;&#x2F;前面的[数量代表数组的维度数，I处的位置为数组的对应类型（I&#x3D;int，F&#x3D;float等）<br>​		System.out.println(arr[0] [0]);&#x2F;&#x2F;0<br>​		int[ ] [ ] arr1 &#x3D; new int[3] [ ];<br>​		System.out.println(arr[1]);&#x2F;&#x2F;null<br>​		System.out.println(arr[1] [0]);&#x2F;&#x2F;报错（空指针）</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​		对于初始化方式一：外层元素的初始化值为地址值<br>​						内层元素的初始化值与一维数组初始化情况相同<br>​		对于初始化方式二：外层元素的初始化值为null<br>​						内层元素的初始化值不能调用，否则报错</p>
<pre><code>6.数组的内存解析：--
</code></pre>
<h2 id="数组中涉及的常见算法："><a href="#数组中涉及的常见算法：" class="headerlink" title="数组中涉及的常见算法："></a>数组中涉及的常见算法：</h2><pre><code>    数组的变量赋值：当同纬数组执行arr1 = arr2操作时，是将arr2的地址值赋给了arr1
    数组的复制：arr1 = new int[arr2.length];
                for(int i = 0;i&lt;arr1.length;i++)
                &#123;
                    arr1[i] = arr2[i];
                &#125;
    数组的反转：方式一
                for(int i = 0;i &lt; arr.lenght / 2;i++)
                &#123;
                    String temp = arr[i];
                    arr[i] = arr[arr.length - i - 1 ];
                    arr[arr.length - i - 1 ] = temp;
                &#125;
                方式二
                for(int i = 0,j = arr.length -1; i &lt; j ;i++,j--)
                &#123;
                    String temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                &#125;
    数组的查找（或搜索）
                线性查找：地毯式
                String dest = &quot;AA&quot;;
                boolean isFlag = true;
                for(int i = 0;i&lt;arr.length;i++)
                &#123;
                    if(dest.equals(arr[i]))
                    &#123;
                        syso&quot;find dest&quot;;
                        isFlag = false;
                        break;
                    &#125;
                &#125;
                if(isFlag)&#123;syso&quot;not found the number&quot;&#125;

                二分法查找：快速式（前提：所要查找的数组必须有序）
                int dest = -56;
                int head = 0;//初始的首索引
                int end = arr.length -1;//初始的末索引
                boolean isFlag = true
                while(head &lt;= end)
                &#123;
                    int middle = (head + end)/2;
                    if(dest == arr[middle])
                    &#123;
                    syso&quot;find the number&quot;
                    isFlag = false
                    break;
                    &#125;else
                    if(arr[middle] &gt; dest)
                    &#123;
                        end = middle - 1;
                    &#125;else
                    head = middle + 1;
                &#125;
                if(isFlag)&#123;syso&quot;not found the number&quot;&#125;
    排序算法：
        冒泡排序：相邻两个数组的元素多次比较大小进行排序
            for(int i = 0;i &lt; arr.length - 1;i++)
            &#123;
                for(int j = 0;j &lt; arr.length - 1 - i;j++)
                &#123;
                    if(arr[j] &gt; arr[j+1])
                    &#123;
                        int temp = arr[j];
                        arr[j] = arr[j+1]
                        arr[j+1] = temp;
                    &#125;
                &#125;
            &#125;
    算法的工具类：java.util.Arrays
        常用：
            boolean equals(int[] a,int [b])		判断两个数组是否相等
            String toSting(int[] a)				输出数组信息
            void fill(int[] a,int val)			将指定值填充到数组之中
            void sort(int[] a)					对数组进行排序
            int binarySearch(int[] a,int key)	对排序后的数组进行二分法检索指定的值

*算法的5大特征：输入、输出、有限性、确定性、可行性

数组中常见的异常：
    1.数组角标异常：ArrayIndexOutOfBoundsExcetion
    2.空指针异常：NullPointerException
</code></pre>
<h1 id="面向对象："><a href="#面向对象：" class="headerlink" title="面向对象："></a>面向对象：</h1><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象:"></a>面向对象:</h4><p>​	强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做					</p>
<h4 id="面向过程："><a href="#面向过程：" class="headerlink" title="面向过程："></a>面向过程：</h4><p>​	强调功能行为，以函数为最小单位，考虑怎么做</p>
<h2 id="面向对象的三大特征："><a href="#面向对象的三大特征：" class="headerlink" title="面向对象的三大特征："></a>面向对象的三大特征：</h2><p>​	封装、继承、多态</p>
<h2 id="面向对象的两个要素："><a href="#面向对象的两个要素：" class="headerlink" title="面向对象的两个要素："></a>面向对象的两个要素：</h2><h3 id="1-类："><a href="#1-类：" class="headerlink" title="1.类："></a>1.类：</h3><p>​				对一类事物的描述，是抽象的、概念上的定义</p>
<h3 id="2-对象："><a href="#2-对象：" class="headerlink" title="2.对象："></a>2.对象：</h3><p>​				是实际存在的该类事物的每个个体，也被称为实力（instance）</p>
<h4 id="设计类其实就是设计类的成员"><a href="#设计类其实就是设计类的成员" class="headerlink" title="*设计类其实就是设计类的成员"></a>*设计类其实就是设计类的成员</h4><p>​		常见类的成员有：	属性 &#x3D; 成员变量 &#x3D; field &#x3D; 域、字段<br>​						方法 &#x3D; 成员方法 &#x3D; 函数 &#x3D; method</p>
<h4 id="java类的实例化就是创建类的对象"><a href="#java类的实例化就是创建类的对象" class="headerlink" title="*java类的实例化就是创建类的对象"></a>*java类的实例化就是创建类的对象</h4><p>​			如：创建一个名为Try类的对象的方法为：Try t1 &#x3D; new Try();<br>​		调用属性的方式： 对象.属性<br>​		调用方法的方式： 对象.方法<br>​			如：Scanner sca &#x3D; new Scanner(  System.in  );</p>
<p>​	*如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性（非static的）<br>​	*如果两个实例化对象之间相互赋值是在地址值层面上的，因此两者变量会使用同一套变量</p>
<h3 id="类中属性的使用："><a href="#类中属性的使用：" class="headerlink" title="类中属性的使用："></a>类中属性的使用：</h3><p>属性（成员变量）  vs  局部变量</p>
<h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><p>​	定义变量的格式：数据类型 变量名 &#x3D; 变量值;<br>​	先声明，后使用<br>​	变量都有其对应的作用域</p>
<h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><p>​	在类中声明的位置不同：<br>​		属性：直接定义在类的一对{}内<br>​		局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量<br>​	关于权限修饰符的不同<br>​		属性：可以声明属性时，指明其权限，使用权限修饰符<br>​			常用的权限修饰符：private、public、缺省（即不写修饰符）、protected<br>​		局部变量：不可以使用权限修饰符</p>
<h3 id="默认初始化值的情况："><a href="#默认初始化值的情况：" class="headerlink" title="默认初始化值的情况："></a>默认初始化值的情况：</h3><h4 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h4><p>​			整型：0<br>​			浮点型：0.0<br>​			字符型：0（或’\u0000’）<br>​			布尔型：false<br>​			引用数据类型（类、数组、接口）：null</p>
<h4 id="局部变量："><a href="#局部变量：" class="headerlink" title="局部变量："></a>局部变量：</h4><p>​			没有默认初始化值，意味着我们在调用局部变量之前一定要先赋值<br>​			*特别的：形参（方法后小括号中的变量）在调用时，我们赋值即可<br>​	在内存中加载的位置：</p>
<h4 id="属性：-1"><a href="#属性：-1" class="headerlink" title="属性："></a>属性：</h4><p>​			加载到堆空间中（非static）</p>
<h4 id="局部变量：-1"><a href="#局部变量：-1" class="headerlink" title="局部变量："></a>局部变量：</h4><p>​			加载到栈空间中</p>
<h3 id="类中方法的声明和使用"><a href="#类中方法的声明和使用" class="headerlink" title="类中方法的声明和使用"></a>类中方法的声明和使用</h3><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><p>​	描述类应该具有的功能<br>​	比如：Math类：sqrt()\random()...<br>​		 Scanner类：nextXxx()…<br>​		 Arrays类：sort()\binarySearch\toString\equals()...<br>​	方法的声明：权限修饰符 返回值类型 方法名(形参列表){方法体}</p>
<p>*void：没有返回值<br>*static、final、abstract 来修饰的方法后期再补充</p>
<h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><p>​	1.Java规定的四种权限修饰符：（public是使方法权限最大的）<br>​		private、public、缺省、protected<br>​	2.返回值类型：有返回值 vs 没有返回值<br>​		如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时方法中需要使用return关键字来返回指定类型的变量或常量<br>​		如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中就不需要使用return。但是如果使用的话只能写”return;”表示结束此方法的意思（即return后不能声明表达式）</p>
<pre><code>    我们定义方法该不该有返回值？
        ① 题目要求
        ② 凭经验
        具体问题具体分析
方法名：属于标识符，遵循标识符的规则和规范，“见名知意”
形参列表：方法可以声明0个，1个，或多个形参
    格式：数据类型1 形参1,数据类型2 形参2,......
    我们定义方法时，该不该定义形参？
        ① 题目要求
        ② 凭经验
方法体：方法功能的体现
</code></pre>
<h2 id="return关键字的使用："><a href="#return关键字的使用：" class="headerlink" title="return关键字的使用："></a>return关键字的使用：</h2><p>​	使用范围：使用在方法体中<br>​	作用：① 结束方法 ② 针对于有返回值类型的方法，使用“return 数据;”的方法返回所要的数据<br>​	注意点：return关键字后面不可以声明执行语句<br>方法的使用中，可以调用当前类的属性或方法<br>​	特殊的：方法A中又调用了方法A叫做递归方法<br>方法中，不可以定义方法</p>
<p>对象数组：可以在自己设计的类实例化时在其后后加[]来作为一个对象数组，性质与数组相同<br>    如：Test t[] &#x3D; new Test[20];&#x2F;&#x2F;创建数组<br>        for(int i &#x3D; 0;i &gt; t.length;i++)<br>        {<br>            t[i] &#x3D;  new Test();&#x2F;&#x2F;创建对象<br>        }<br>    *如果要对其中某个属性的排序，需要交换的是数组中的元素而不是只交换属性<br>    *在一些操作功能可以封装到方法中（自己设计类中的方法）</p>
<p>引用类型的变量，只可能存储两类值：null 或 地址值（含变量的类型）</p>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>​	直接new 类名; 的方式来创造对象<br>​	理解：我们创建的对象，没有显示的赋给一个变量名，即为匿名对象<br>​	特征：匿名对象只能调用一次（即在多次调用时每一个都是一个新的匿名对象）<br>​	使用：临时创造一个变量来满足程序运行需求（省事）</p>
<h2 id="方法的重载（overload）loading…"><a href="#方法的重载（overload）loading…" class="headerlink" title="方法的重载（overload）loading…"></a>方法的重载（overload）loading…</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>​		在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可，既两同一不同：同一个类、相同方法名<br>​																								参数列表不同：参数个数不同，参数类型不同，参数传入顺序不同<br>​		举例：如数组中的sort();<br>​	判断是否是重载：<br>​		跟方法的权限修饰符，返回值类型，形参变量名，方法体都没有关系！<br>​	在通过对象调用方法时，如何确定某一个指定方法：<br>​		方法名 &gt; 参数列表</p>
<h3 id="可变个数形参的方法（jdk-5-0新增内容）"><a href="#可变个数形参的方法（jdk-5-0新增内容）" class="headerlink" title="可变个数形参的方法（jdk 5.0新增内容）"></a>可变个数形参的方法（jdk 5.0新增内容）</h3><h4 id="具体使用："><a href="#具体使用：" class="headerlink" title="具体使用："></a>具体使用：</h4><p>​		可变个数形参的格式：数据类型 … 变量名 		如：test(String … s)<br>​		当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个，2个……（与多参数情况一样，多个参数用逗号隔开）<br>​		可变个数形参的方法与本类中方法名相同，形参不同的方法之间重载<br>​		*特别的,可变个数形参的本质和数组相同，其与相同情况下的数组做形参的情况不构成重载，在可变形参的方法下的算法与数组的情况相同<br>​		可变个数形参在方法的形参中，必须声明在末尾（即使用多个形参的时候可变个数形参的位置必须放在末尾<br>​		可变个数形参在方法的形参中，最多只能声明一个可变形参</p>
<h3 id="Java里方法的参数传递只有一种：值传递"><a href="#Java里方法的参数传递只有一种：值传递" class="headerlink" title="Java里方法的参数传递只有一种：值传递"></a>Java里方法的参数传递只有一种：值传递</h3><p>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参<br>形参是引用数据类型：将实参应用数据类型变量的“地址值”传递给形参</p>
<h4 id="值传递机制："><a href="#值传递机制：" class="headerlink" title="值传递机制："></a>值传递机制：</h4><p>​			如果参数是基本数据类型，此时实参赋给形参的是实参存储的数据值<br>​			如果参数是引用数据类型，此时实参付给形参的是实参存储数据的地址值</p>
<h4 id="方法的形参传递机制：值传递"><a href="#方法的形参传递机制：值传递" class="headerlink" title="方法的形参传递机制：值传递"></a>方法的形参传递机制：值传递</h4><p>​	形参：方法定义时，声明在小括号内的参数		实参：方法调用时，实际传递给形参的数据<br>​	值传递机制：如果参数是基本数据类型，此时实参付给形参的是实参真实存储的数据值</p>
<h2 id="了解递归方法的使用："><a href="#了解递归方法的使用：" class="headerlink" title="了解递归方法的使用："></a>了解递归方法的使用：</h2><p>​	递归方法：一个方法体调用他自身<br>​	方法的递归包含了一种隐式的循环，他会重复执行某段代码，但这种宠物执行无需循环控制<br>​	递归一定要向已知方向递归，否则这种递归变成了无穷递归，类似于死循环</p>
<h2 id="面向对象的特征一："><a href="#面向对象的特征一：" class="headerlink" title="面向对象的特征一："></a>面向对象的特征一：</h2><p>​	封装与隐藏：<br>​		当我们创建一个对象以后，我们可以通过“对象、属性”的方式，对对象的属性进行赋值。在对实际问题中，我们往往需要给属性赋值进行赋值时加入额外的限制条件，这个条件就不能在属性声明时体现，我们只能通过方法进行限制的添加。同时，我们需要避免用户再使用“对象，属性”的方式对属性进行赋值。则需要对属性声明为私有的（private）此，针对于属性就体现了封装性</p>
<pre><code>封装性的体现：
    我们将类的属性xxx私有化（private），同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值
*拓展：封装线的体现：① 如上 ② 不对外暴露的私有的方法 ③ 单例模式 ... ...

封装性的体现需要权限修饰符来配合：
    Java规定的4种权限（从小到大排列）：private、缺省、protected、public
        private只在类内部可以直接访问
        缺省在同一个包中可以直接访问
        protected在不同包的子类也可以直接访问
        public可以在同一个工程下使用
    四种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类
    具体的，四种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类；修饰类的话，只能使用缺省、public
总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时可见性的大小
</code></pre>
<p>类的结构之三：构造器（或构造方法、constructor）的使用<br>    什么是构造器：<br>        Person p &#x3D; new Person()		其中带括号的Person()即为构造器<br>    构造器的作用：<br>        创建对象（创建类的对象：new + 构造器）<br>        初始化对象的属性（依靠形参）信息（构造器本体中增加方法等）<br>    说明：<br>        如果没有显式定义类的构造器的话，则系统默认提供一个空参的构造器<br>        定义构造器的格式：权限修饰符 类名（形参列表）{}<br>        一个类中定义的多个构造器，彼此构成重载<br>        一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器<br>        一个类中，至少会有一个构造器<br>    总结：<br>        属性赋值的先后顺序：<br>            1.默认初始化<br>            2.显式初始化<br>            3.构造器中初始化<br>            （上述方法一般在一个对象中只进行一次）<br>            4.通过“对象.方法”或“对象.属性”的方式赋值<br>            （上述方法一般在一个对象中可进行多次）<br>            以上操作的先后顺序： 1 - 2 - 3 - 4</p>
<h3 id="javaBean"><a href="#javaBean" class="headerlink" title="javaBean"></a>javaBean</h3><p>JavaBean是一种Java语言写成的可重用组件<br>所谓的JavaBean是符合如下标准的Java类：<br>    类是公共的<br>    有一个无参的公共的构造器（系统默认的构造器权限与类的权限相同）<br>    有属性，且有对应的get、set方法</p>
<h3 id="UML类图："><a href="#UML类图：" class="headerlink" title="UML类图："></a>UML类图：</h3><p>​	左上角为包名<br>​	中间表头为类名<br>​	类名下方为属性（“：”前是属性名，“：”后是属性的类型）<br>​	属性下方为方法，若方法有下划线表示为构造器<br>​	+ 表示public类型，- 表示private类型，# 表示protected类型<br>​	方法的写法：<br>​		方法的类型（+、-） 方法名(参数名:参数类型):返回值类型</p>
<h2 id="this关键字的使用："><a href="#this关键字的使用：" class="headerlink" title="this关键字的使用："></a>this关键字的使用：</h2><p>​	this可以用来修饰：属性、方法、构造器<br>​	this修饰属性和方法：<br>​		this理解为：当前对象<br>​	在类的方法中，我们可以使用“this.属性”或“this.方法”的方式，调用当前对象属性或方法。但是通常情况下，我们都选择省略“this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用“this.变量”的方式，表明此变量是属性而非形参</p>
<pre><code>在类的构造器中，我们可以使用“this.属性”或“this.方法”的方式，调用当前正在创建的对象属性或方法。但是通常情况下，我们都选择省略“this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用“this.变量”的方式，表明此变量是属性而非形参

this调用构造器：
    我们在类的构造器中，可以显式的使用“this(形参列表)”方式，调用本类中指定的其他构造器
    构造器中不能通过此方式调用自己
    如果一个类中有n个构造器，则最多有n-1个构造器中使用了“this(形参列表)”
    规定：“this(形参列表)”必须声明在当前构造器的首行
    构造器内部，最多只能声明一个“this(形参列表)”，用来调用其他的构造器
</code></pre>
<h2 id="package关键字的使用"><a href="#package关键字的使用" class="headerlink" title="package关键字的使用"></a>package关键字的使用</h2><p>​	为了更好的实现项目组类的管理，提供包（package）的概念<br>​	使用package声明类或接口所属的包，声明在源文件的首行<br>​	包，属于标识符，遵循标识符的命名规则、规范（xxxyyyzzz）、“见名知意”<br>​	每“.”一次，就代表一层文件目录<br>​	同一个包下不能命名同名的接口或类</p>
<h2 id="import（导入）关键字的使用"><a href="#import（导入）关键字的使用" class="headerlink" title="import（导入）关键字的使用"></a>import（导入）关键字的使用</h2><p>​	在源文件中显式的使用import结构导入指定包下的类、接口<br>​	声明在包的声明和类的声明之间<br>​	如果需要导入多个结构，并列写出即可<br>​	可以使用“xxx.*”的方式，表示导入xxx包下的所有结构<br>​	如果使用的类或接口是java.lang包下定义的，则可以省略import结构<br>​	如果使用的类或借口是本包下定义的，则可以省略import结构<br>​	如果在源文件中使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显式（com.fireking.java.Account）<br>​	使用“xxx.*”的方式表明可以调用xxx包下的所有结构，但是如果使用的是xxx子包下的结构，则仍需要显示导入</p>
<pre><code>import static：导入指定类或接口中的静态结构
</code></pre>
<h2 id="面向对象的特征二："><a href="#面向对象的特征二：" class="headerlink" title="面向对象的特征二："></a>面向对象的特征二：</h2><h3 id="继承性：使用到extends关键字"><a href="#继承性：使用到extends关键字" class="headerlink" title="继承性：使用到extends关键字"></a>继承性：使用到extends关键字</h3><p>​	在一个类的构建中使用：class Student extends Person  的方式就可以使Student类继承Person类的代码<br>​	Student：子类、派生类、subclass<br>​	Person：父类、超类、基类、superclass</p>
<pre><code>体现：一旦子类火继承父类B之后，子类A就获取了父类B中声明的所有的结构，属性，方法
特比的：父类中声明为私有的属性和方法，子类继承以后，仍然认为获取了父类中的私有结构，只是因为封装性的影响，似的子类不能直接调用父类的结构而已

子类继承父类以后，还可以定义属于自己的属性和方法，实现功能的拓展
子类和父类的关系，不同于子集和集合的关系

一个类可以被多个子类继承
Java中类的单继承性：一个类只能有一个父类
子父类是相对的概念
子类直接继承的父类称为：直接父类。间接继承的父类称为：间接父类
子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法

如果我们没有显式的声明一个类的父类，则此类继承于java.lang.Object类
所有的java类（除了java.lang.Object类之外）都直接或间接的继承于java.lang.Object类
</code></pre>
<h3 id="重写（override-overwrite）："><a href="#重写（override-overwrite）：" class="headerlink" title="重写（override&#x2F;overwrite）："></a>重写（override&#x2F;overwrite）：</h3><p>​	子类继承父类以后，可以对父类中同名参数的方法，进行覆盖操作<br>​	重写以后，当创建子类对象以后，通过子类对象调用子父类中同名参数的方法时，实际执行的是子类重写父类的方法</p>
<pre><code>重写的规定：
    方法的声明：权限修饰符 返回值类型 方法名(形参列表)
    &#123;
        //方法体
    &#125;

    约定俗成：子类中的叫重写的方法，父类中的叫被重写的方法

    *子类重写的方法的方法名形参列表于父类被重写的方法名和形参列表相同
    子类重写的方法的权限修饰符不能小于匪类被重写的权限修饰符
        特殊情况：子类不能重写父类中声明为private权限的方法
    返回值类型：
        父类被重写的方法的返回值类型是void，则子类重写的方法的返回值只能是void
        父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
        父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值必须是相同的基本数据类型
    子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理处讲）
    子类和父类中同名通参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）

@Override：重写的注解，写在重写方法的前面首行（后面再细说）
</code></pre>
<h3 id="super关键字的使用"><a href="#super关键字的使用" class="headerlink" title="super关键字的使用"></a>super关键字的使用</h3><p>​	super理解为：父类的…<br>​	super可以用来调用：属性、方法、构造器<br>​	super的使用：<br>​		我们可以在子类的方法或构造器中，通过使用“super.属性”或“super.方法”的方式显式的调用父类中声明的属性或方法，但是通常情况下我们省略super.<br>​		</p>
<pre><code>    特殊情况：当子类和父类当中定义了重名的属性时，我们要想在子类当中调用父类中声明的属性，则必须显式的使用super.方式表明使用的是父类中声明的属性

    super调用构造器：
        我们可以在子类的构造器中显式的使用“super(形参列表);”的方式调用父类中声明的指定的构造器
        “super(形参列表)”的使用必须声明在子类构造器的首行！  我们在类的构造器中针对于&quot;this(形参列表)&quot;或“super(形参列表)”只能二选一

        在构造器的首行，没有显式的声明“this或super(形参列表)”则默认调用的是父类中空参的构造器（super()）
        在类的多个构造器中，至少有一个类的构造器中使用了“super(形参列表)”调用父类中的构造器
</code></pre>
<h2 id="面向对象特征之三：多态性"><a href="#面向对象特征之三：多态性" class="headerlink" title="面向对象特征之三：多态性"></a>面向对象特征之三：多态性</h2><p>​	理解多态性：可以理解为一个事物的多种形态</p>
<pre><code>对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）
    Person p = new Man();
多态的使用：虚拟方法调用---当调用子父类同名同参方法时，实际执行的是子类重写父类的方法   （对于同名实例变量则不可能被覆盖，子父类中二者并存）
    有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法（动态绑定、晚绑定）
                                                                                            重载称为：静态绑定、早绑定
总结：编译看左边，执行看右边
多态性的使用前提：1.类的继承关系  2.方法的重写

对象的多态性，只适用于方法，不适用于属性，因此在属性上，编译和运行均只看左边

多态是运行时行为
</code></pre>
<h3 id="instanceof关键字："><a href="#instanceof关键字：" class="headerlink" title="instanceof关键字："></a>instanceof关键字：</h3><p>​	有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时只能调用父类中声明的属性和方法，子类的属性和方法不能调用，此时需要向下转型，使用强制类型转换符(intenseof)<br>​	Person p &#x3D; new Man();  向上转型：多态<br>​	Man m &#x3D; (Man)p;  向下转型</p>
<pre><code>*使用强转时，可能出现ClassCastException(转换类型异常)
</code></pre>
<h3 id="instanceof关键字的使用："><a href="#instanceof关键字的使用：" class="headerlink" title="instanceof关键字的使用："></a>instanceof关键字的使用：</h3><p>​	a instanceof A：判断对象a是否是类A的实例。如果是，返回true，如果不是，返回false<br>​	使用情景：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true就进行向下转型，如果返回false那就不进行向下转型<br>​	如果a instanceof A返回true，则a instanceof B也返回true，其中，B是A类的父类</p>
<h2 id="java-lang-Object类"><a href="#java-lang-Object类" class="headerlink" title="java.lang.Object类"></a>java.lang.Object类</h2><p>​	1.Object类是所有Java类的根父类<br>​	2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类<br>​	3.Object类中的功能（属性、方法）就具有通用性<br>​		属性：无<br>​		方法：equals() &#x2F; toString() &#x2F; getClass() &#x2F; hashCode() &#x2F; clone() &#x2F; finalize() &#x2F; wait() 、 notify() 、 notifyAll()</p>
<pre><code>4.Object类只声明了一个空参的构造器
</code></pre>
<p>*&#x3D;&#x3D;：对于引用数据类型来讲，比较的是两个引用数据类型的变量的地址值是否相同，相同输出true，不相同输出false<br>面试题： &#x3D;&#x3D; 和 equals() 的区别<br>    &#x3D;&#x3D;：运算符<br>        1.可以使用在基本数据类型变量（boolean类型除外）和引用数据类型变量中<br>        2.如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）<br>          如果比较的是引用数据类型变量：比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体</p>
<pre><code>equals()：一个方法
    1.只能适用于引用数据类型
    2.Object类中equals()的定义：
        public boolean equal(Object obj)
        &#123;
            return(this == obj);
        &#125;
    说明：Object类中定义的equals()和==作用是相同的，比较两个对象的地址值是否相同
    4.像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址值是否相同，而是比较两个对象的&quot;实体内容&quot;是否相同
    5.通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的&quot;实体内容&quot;是否相同，那么我们就需要对Object类中的equals()方法进行重写
    
重写equals()方法的原则：
    对称性  x.equals(y)返回值是true，那么y.equals(x)返回值也是true
    自反性  x.equals(x)的返回值必须是true
    传递性  如果x.equals(y)返回值是true，而且y.equals(z)返回值也是true，那么x.equals(z)返回值也是true
    一致性  如果x.equals(y)返回值是true，那么不管重复x.equals(y)多少次返回值都是true
    *任何情况下，x.equals(null)永远返回值是&quot;false&quot;，null.equals(x)永远返回值是&quot;false&quot;
</code></pre>
<h3 id="Object类中toString-的使用："><a href="#Object类中toString-的使用：" class="headerlink" title="Object类中toString()的使用："></a>Object类中toString()的使用：</h3><p>​	1.当我们输出一个对象的引用时，实际上就是调用当前对象的toString()<br>​	2.Object类中toString()的定义：<br>​		public String toString()<br>​		{<br>​			return getClass().getName + “@” + Integer.toString(hashCode());<br>​		}<br>​	3.像String、Date、File、包装类等都重写了Object类中的toString()方法，使得在调用对象的toString()时，返回”实体内容”信息<br>​	4.自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p>
<h2 id="Java中的JUnit单元测试"><a href="#Java中的JUnit单元测试" class="headerlink" title="Java中的JUnit单元测试"></a>Java中的JUnit单元测试</h2><p>​	步骤：<br>​	1.选中当前工程 - 右键选择：build path - add libraries - JUnit 4<br>​	2.创建Java类，进行单元测试<br>​		此时类的要求：① 此类是public的  ② 此类提供公共的无参构造器<br>​	3.此类中声明单元测试方法<br>​		此时的单元测试方法：方法的权限是public，没有返回值，没有形参<br>​	4.此单元测试方法上需要声明注解@Test，并在单元测试类中导入：import org.junit.Test<br>​	5.声明好单元测试方法以后，就可以在方法体内测试相关的代码<br>​	6.写完代码以后，左键双击选中单元测试方法名，右键选择：Run as - JUnit Test</p>
<pre><code>说明：
1.如果执行结果没有任何异常：绿条
2.如果程序执行结果出现异常：红条
</code></pre>
<h2 id="包装类的使用："><a href="#包装类的使用：" class="headerlink" title="包装类的使用："></a>包装类的使用：</h2><p>​	1.Java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征<br>​	2.需掌握：基本数据类型、包装类、String三者之间的相互转换<br>​		基本数据类型 –&gt; 包装类：调用包装类的构造器（如：int num1;  Integer in1 &#x3D; new Integer(num1);）    *特别的，对于Boolean，非true则必为false<br>​		包装类 –&gt; 基本数据类型：调用包装类Xxx的xxxValue();（如：int i1 &#x3D; in1.intValue;）<br>​	&#x2F;&#x2F;JDK 5.0新特性<br>​	*自动装箱：基本数据类型 –&gt; 包装类<br>​		int num1 &#x3D; 10;	Integer in1 &#x3D; num1;<br>​	*自动拆箱：包装类 –&gt; 基本数据类型<br>​		int num1 &#x3D; in1;</p>
<pre><code>    基本数据类型、包装类 --&gt; String类型：调用String重载的valueOf(Xxx xxx);
    方式一：连接运算
        String str = num + &quot;&quot;;
    方式二：调用valueOf(Xxx xxx);
        String str =String.valueOf(num);
    String类型 --&gt; 基本数据类型、包装类：调用包装类的parseXxx();
        String str = &quot;123&quot;;
        int num = Integer.parseInt(str);

Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[]，保存了从 -128 ~ 127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在-128~127范围内时，可以直接使用数组中的元素，不用再去new了，以此提高效率
</code></pre>
<h2 id="static关键字的使用"><a href="#static关键字的使用" class="headerlink" title="static关键字的使用"></a>static关键字的使用</h2><p>​	1.static：静态的<br>​	2.static可以用来修饰：属性、方法、代码块、内部类<br>​	*static不能用来修饰构造器</p>
<pre><code>3.使用static修饰属性：静态变量
    属性，按是否使用static修饰，又分为：静态属性和非静态属性（实例变量）
        实例变量：我们创建了多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样属性值的修改

        静态变量：我们如果创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此时静态变量时，是修改过的

        static修饰属性的其他说明：
            静态变量随着类的加载而加载
            静态变量的加载要早于对象的创建，可以通过“类.静态变量”的方式进行调用，赋值等操作
            由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中
            类变量（静态变量）可以被类和对象调用，实例变量只能被对象调用不能被类调用

        静态属性举例：System.out; Math.PI;

4.使用static修饰方法：
    随着类的加载而加载，可以通过“类.静态方法”的方式进行调用
    静态方法可以被类和对象调用，非静态方法只能被类调用不能被对象调用
    非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性

5.static注意点：
    在静态方法内，不能使用this关键字、super关键字
    关于静态属性和静态方法的使用，大家都从生命周期的角度去理解

6.开发中，如何确定一个属性是否要声明为static
    属性是可以被多个对象所共享的，不会随着对象的不同而不同的，可以声明为static
    类中的常量也常常声明为static

  开发中，如何确定一个方法是否要声明为static
  	操作静态属性的方法，通常设置为static的
  	工具类中的方法，习惯上声明为static的。比如：Math、Arrays、Collections
</code></pre>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例设计模式："><a href="#单例设计模式：" class="headerlink" title="单例设计模式："></a>单例设计模式：</h2><p>​		采取一定方法保证在整个软件系统中对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p>
<h3 id="方法一：饿汉式"><a href="#方法一：饿汉式" class="headerlink" title="方法一：饿汉式"></a>方法一：饿汉式</h3><pre><code>    class Bank
    &#123;
        // 私有化类的构造器
        private Bcank()
        &#123;	&#125;
    //内部创建类的对象
    private static Bank instance = new Bank();

    //提供公共的方法，返回类的对象（静态方法才可以在没有对象创建时直接调用）
    piblic static Bank getInstance()
    &#123;
        return instance;  //（静态方法只能调用静态属性）
    &#125;
&#125;
</code></pre>
<h3 id="方法二：懒汉式"><a href="#方法二：懒汉式" class="headerlink" title="方法二：懒汉式"></a>方法二：懒汉式</h3><pre><code>    class Order()
&#123;
    //私有化类的构造器
    private Order()
    &#123;
        //先声当前类的对象，没有初始化
        private static Order instance = null;
    //声明public、static的返回当前类对象的方法
    public static Order getInstance()
    &#123;
        if(instance == null)
        &#123;
            instance = new Order();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<p>}</p>
<h2 id="区分饿汉式和懒汉式："><a href="#区分饿汉式和懒汉式：" class="headerlink" title="区分饿汉式和懒汉式："></a>区分饿汉式和懒汉式：</h2><p>​	饿汉式：<br>​		好处：饿汉式是线程安全的<br>​		坏处：对象加载时间过长<br>​	懒汉式：<br>​		好处：延迟对象的创建<br>​		目前写法坏处坏处：线程不安全（到多线程内容时再修改）</p>
<h2 id="main-方法的使用说明"><a href="#main-方法的使用说明" class="headerlink" title="main()方法的使用说明"></a>main()方法的使用说明</h2><p>​	1.main()方法作为程序的入口<br>​	2.main()方法也是一个普通的静态方法<br>​	3.main()方法也可以作为我们与控制台交互的方式（之前：使用Scanner）</p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>类的成员之四：代码块（初始化块）  只有一个大括号，前面只能用static修饰<br>    1.代码块的作用：用来初始化类、对象<br>    2.代码块如果有修饰的话，只能使用static<br>    3.分类：静态代码块 vs 非静态代码块</p>
<pre><code>    3.1静态代码块：static&#123;&#125;
        内部可以有输出语句
        随着类的加载而执行，且只执行一次
        作用：初始化类的信息
        如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行
        静态代码块的执行要优先于非静态代码块的执行
        静态代码块内只能调用静态的属性或方法，不能调用非静态的结构

    3.2非静态代码块：&#123;&#125;
        内部可以有输出语句
        随着对象的创建而执行
        每创建一个对象，就执行一次非静态代码块
        作用：可以在创建对象时，对对象的属性等进行初始化
        如果一个类定义了多个非静态代码块，则按照声明先后顺序执行
        非静态代码块内可以调用静态的属性、静态的方法或非静态的属性、非静态的方法

    *由父及子，静态先行
</code></pre>
<h2 id="对属性可以赋值的位置："><a href="#对属性可以赋值的位置：" class="headerlink" title="对属性可以赋值的位置："></a>对属性可以赋值的位置：</h2><p>​	1.默认初始化<br>​	2.显式初始化<br>​	3.构造器中初始化<br>​	4.有了对象以后，可以通过：对象.属性 或 对象.方法 的方式进行赋值<br>​	5.在代码块中赋值<br>*执行的先后顺序：1 - 2 or 5（此二者与声明先后顺序有关，先声明先执行） - 3 - 4</p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><h3 id="final：最终的"><a href="#final：最终的" class="headerlink" title="final：最终的"></a>final：最终的</h3><p>​	1.final可以用来修饰的结构：类、方法、变量<br>​		final用来修饰一个类：此类不能被其他类继承（比如：String类、System类、StringBuffer类）<br>​		final用来修饰方法：表明此方法不可以被重写（比如：Object类中的getClass();）<br>​		final用来修饰变量：此时的“变量”就称为是一个常量（常量名全部字母大写）<br>​	2.final修饰属性，可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化<br>​	3.final修饰局部变量：尤其是使用final修饰形参时，表明此形参是常量。当我们调用此方法时，给常量形参附一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值<br>​	4.static final 用来修饰属性：全局常量</p>
<h2 id="abstract关键字的使用："><a href="#abstract关键字的使用：" class="headerlink" title="abstract关键字的使用："></a>abstract关键字的使用：</h2><p>​	abstract：抽象的<br>​	abstract 可以用来修饰的结构：类、方法<br>​		abstract 修饰类：抽象类：<br>​			此类不能实例化（不能造对象）<br>​			抽象类中一定有构造器，便于子类对象实例化时调用（super）<br>​			开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作<br>​		abstract 修饰方法：抽象方法<br>​			格式：public abstract void eat();<br>​			抽象方法只有方法的声明，没有方法体<br>​			包含抽象方法的类一定是一个抽象类，抽象类里可以没有抽象方法</p>
<pre><code>    abstract不能用来修饰：属性、构造器等结构，不能用来修饰私有方法、静态方法、final的方法，final的类

抽象类不能直接造对象，但是可以通过它造出其匿名子类（要重写抽象方法）起到一次性使用的效果
    Person p = new Person()&#123;@override&#125;;
</code></pre>
<h1 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h1><h2 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h2><p>​		1.接口使用interface来定义<br>​		2.Java中，接口和类是并列的两个结构<br>​		3.如何定义接口：定义接口中的成员<br>​			3.1 JDK7及以前：只能定义全局常量和抽象方法<br>​				全局常量: public static final的，但是书写时，可以省略不写<br>​				抽象方法: public abstract的，也可省略不写<br>​			3.2 JDK8：在7的基础上还能定义静态方法、默认方法（略）<br>​		4.接口中不能定义构造器，意味着其无法被实例化<br>​		5.Java开发中，接口通过让类去实现（implements）的方法去使用<br>​			如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化<br>​			如果没有覆盖接口中的所有抽象方法，则此实现类仍为一个抽象类<br>​		6.Java类可以实现多个接口，弥补了Java单继承性的局限性<br>​			格式：class AA extends BB implements CC,DD,EE<br>​		7.接口与接口之间可以继承，而且可以多继承<br>​			格式：interface CC extends AA,BB</p>
<pre><code>    8.接口的具体使用体现多态性
    9.接口实际上就可以看做是一种规范性

1.创建接口的非匿名实现类的非匿名对象
Flash flash = new Flash();
com.transferData(falsh);
2.创建接口的非匿名实现类的匿名对象
com.transferData(new Printer());
3.创建接口的匿名实现类的非匿名对象
USB phone = new USB()&#123;
    @Override
     ......
&#125;;
com.transferData(phone);
4.创建接口的匿名实现类的匿名对象
com.transferData(new USB()&#123;
    @Override
     ......
&#125;);
</code></pre>
<h1 id="内部类："><a href="#内部类：" class="headerlink" title="内部类："></a>内部类：</h1><p>​	Inner class的名字不能与包含他的外部类类名相同<br>​	1.Java允许将一个类A声明在另一个类B中，则A就是内部类，B成为外部类<br>​	2.内部类的分类： 成员内部类（静态、非静态） vs 局部内部类（方法内、代码块内、构造器内）</p>
<p>​			</p>
<h1 id="Java中常用的类"><a href="#Java中常用的类" class="headerlink" title="Java中常用的类"></a>Java中常用的类</h1><h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><p>如何从键盘（控制台）获取不同类型的变量：需要使用Scanner类<br>    具体实现步骤：<br>        1.导包：import java.util.Scanner;<br>        2.Scanner的实例化：Scanner scan &#x3D; new Scanner(System.in);<br>        3.调用Scanner类的相关方法（next()&#x2F;nextXxx），来获取指定类型的变量：int num &#x3D; scan.nextInt();<br>    *Scanner没有提供char型的相关方法<br>    *如果输入的数据类型的值与要求的类型不匹配时会报异常，导致程序终止</p>
<pre><code>*如果想完成一个区间的求取true/false，在java中不可以直接写成数学的形式，应为在计算中会变成一个布尔型与数值型的计算（无法计算，报错），应当用逻辑运算符来界定其运算范围
</code></pre>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>获取随机数的函数：（值均为double型）<br>    Math.random()  &#x2F;&#x2F;生成数字范围：[0.0,1.0)<br>    因此如果要获取一个在范围[a,b]之间的随机数的公式为：(强转符位，可不加)(Math.random() * (b - a + 1) + a)</p>
<p>四舍五入取整：<br>    Math.round(double d)，返回值为long型</p>
<h2 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h2><p>抛出异常：（使用到throw关键字和RuntimeException方法）<br>    throw new RuntimeException(“传入的数据非法！”)</p>
<h1 id="进制相关："><a href="#进制相关：" class="headerlink" title="进制相关："></a>进制相关：</h1><p>​	二进制以0b开头后面加数字，如：0b10010<br>​	十进制不需要任何加注<br>​	八进制以0开头后面加数字，如：0127<br>​	十六进制以0x开头后面加数字或字母A-F，不区分大小写，如：0X12A</p>
<h1 id="相关注意事项："><a href="#相关注意事项：" class="headerlink" title="相关注意事项："></a>相关注意事项：</h1><p>声明public的类的类名毕竟与源文件名称一致</p>
<p>在一个java源文件中可以声明多个class。但是，最多只能有一个类声明为public的。</p>
<p>程序的入口是main()方法，格式是固定的。</p>
<p>编译后会生成一个或多个字节码文件，字节码文件与java源文件中的类名相同。</p>
<p>每一行执行语句都以“;”结束。<br>输出语句：<br>System.out.println()       先输出数据，然后换行<br>System.out.print()         只输出数据</p>
<h1 id="eclipse常用快捷键："><a href="#eclipse常用快捷键：" class="headerlink" title="eclipse常用快捷键："></a>eclipse常用快捷键：</h1><p>​	补全代码的声明：alt + &#x2F;<br>​	快速修复：ctrl + 1<br>​	批量导包：ctrl + shift + o<br>​	使用或取消单行注释：ctrl + &#x2F;<br>​	使用多行注释：ctrl + shift + &#x2F;<br>​	取消多行注释：ctrl + shift + <br>​	复制指定行的代码：ctrl + alt + down 或 ctrl + alt + up<br>​	删除指定行的代码：ctrl + d<br>​	上下移动代码：alt + up 或 alt + down<br>​	切换到下一行代码空位：shift +enter<br>​	切换到上一行代码空位：ctrl + shift + enter<br>​	如何查看源码：ctrl + 选中指定的结构左键单击 或 ctrl + shift + t 进行搜索查找<br>​	退回到前一个编辑的页面：alt + left<br>​	进入到下一个编辑的页面（针对上面的那条来说的）：alt + right<br>​	光标选中指定的类，查看继承树结构：ctrl + t<br>​	复制：ctrl + c<br>​	撤销：ctrl + z<br>​	反撤销：ctrl + y<br>​	剪切：ctrl + x<br>​	黏贴：ctrl + v<br>​	保存：ctrl + s<br>​	全选：ctrl + a<br>​	格式化代码（整理代码格式）：ctrl + shift + f<br>​	选中数行，整体往后移动（指在同一行内的前后，即左右）：tab<br>​	选中数行，整体往前移动（指在同一行内的前后，即左右）：shift + tab<br>​	在当前类中，显示类结构，并支持搜索指定的方法、属性等（即带搜索能力的outline）：ctrl + o<br>​	批量修改指定的变量名、方法名、类名等：alt + shift + r<br>​	选中的结构大小写的切换：变成大写：ctrl + shift + x<br>​						  变成小写：ctrl + shift + y<br>​	调出生成getter&#x2F;setter&#x2F;构造器等结构：alt + shift + s<br>​	显式当前选择资源（工程 or 文件）的属性：alt + enter<br>​	快速查找：参照选中的Word快速定位到下一个：ctrl + k</p>
<pre><code>关闭当前窗口：ctrl + w
关闭所有的窗口：ctrl + shift + w
查看指定的结构使用过的地方：ctrl + alt + g
查找与替换：ctrl + f
最大化当前的View： ctrl + m
直接定位到当前行的首位：home
直接定位到当前行的末尾：end




游戏鼠标的两个侧键默认为：alt + left 和 alt + right 的按键绑定
</code></pre>
<p>[2]: </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fire0king.github.io">Fire King</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fire0king.github.io/2025/09/02/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://fire0king.github.io/2025/09/02/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://fire0king.github.io" target="_blank">Ciallo～(∠・ω< )⌒☆</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/dos/">dos</a></div><div class="post-share"><div class="social-share" data-image="/img/github_icon.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/02/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%AD/" title="Java学习笔记-续"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java学习笔记-续</div></div><div class="info-2"><div class="info-item-1">之前学习知识的重点补充短路与逻辑与，短路或与逻辑或的主要区别：​	短路与（&amp;）在运算时，当左边的条件为false时，右边的条件直接不判断，输出false​	短路或（|）在运算时，当左边的条件为true时，右边的条件直接不判断，输出true 位运算（&gt;&gt;      &lt;&lt;）:​	左移几位相当于将原数乘2的几次方，右移相当于除以2的几次方。 main方法相关main方法是static修饰的原因：JVM直接通过 类名.main() 的方式将程序入口函数调用起来，让程序开始运行。main是void的原因：main方法只调用方法，不需要向JVM返回任何值。 抽象类相关抽象类不能new对象，但是抽象类有子类，子类的构造方法中会存在super语句（隐式或显式）找父类构造方法，所以抽象类是有构造器的。抽象类一定是父类，但是不一定是顶层父类。抽象类中可以没有抽象方法。abstract不能与private，final，static关键字共存。 抽象类中不一定只有抽象方法，甚至可能没有抽象方法（只作为不允许外部new实例） 接口相关接口经过编译之后，硬盘上也会生成对应的c...</div></div></div></a><a class="pagination-related" href="/2025/08/28/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/02/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%AD/" title="Java学习笔记-续"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-02</div><div class="info-item-2">Java学习笔记-续</div></div><div class="info-2"><div class="info-item-1">之前学习知识的重点补充短路与逻辑与，短路或与逻辑或的主要区别：​	短路与（&amp;）在运算时，当左边的条件为false时，右边的条件直接不判断，输出false​	短路或（|）在运算时，当左边的条件为true时，右边的条件直接不判断，输出true 位运算（&gt;&gt;      &lt;&lt;）:​	左移几位相当于将原数乘2的几次方，右移相当于除以2的几次方。 main方法相关main方法是static修饰的原因：JVM直接通过 类名.main() 的方式将程序入口函数调用起来，让程序开始运行。main是void的原因：main方法只调用方法，不需要向JVM返回任何值。 抽象类相关抽象类不能new对象，但是抽象类有子类，子类的构造方法中会存在super语句（隐式或显式）找父类构造方法，所以抽象类是有构造器的。抽象类一定是父类，但是不一定是顶层父类。抽象类中可以没有抽象方法。abstract不能与private，final，static关键字共存。 抽象类中不一定只有抽象方法，甚至可能没有抽象方法（只作为不允许外部new实例） 接口相关接口经过编译之后，硬盘上也会生成对应的c...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/github_icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Fire King</div><div class="author-info-description">一个还在建设中的小站ᗜvᗜ</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Fire0King"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DOS%E5%91%BD%E4%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">DOS命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#win%E7%9A%84%E7%9B%B8%E5%85%B3DOS%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.</span> <span class="toc-text">win的相关DOS命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%E7%9A%84DOS%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.</span> <span class="toc-text">JDK的DOS命令:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E8%AF%AD%E8%A8%80%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">java语言：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">2.1.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.2.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-number">2.3.</span> <span class="toc-text">保留字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">2.4.</span> <span class="toc-text">标识符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">2.4.1.</span> <span class="toc-text">*规则：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E8%8C%83"><span class="toc-number">2.4.2.</span> <span class="toc-text">*规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">2.4.3.</span> <span class="toc-text">*注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">*注意：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">java定义变量的格式：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">*数据类型：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">4.0.0.2.</span> <span class="toc-text">基本数据类型：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%9E%8B%EF%BC%9A"><span class="toc-number">4.0.0.2.1.</span> <span class="toc-text">数值型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-number">4.0.0.2.2.</span> <span class="toc-text">字符型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-number">4.0.0.2.3.</span> <span class="toc-text">布尔型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">4.0.0.3.</span> <span class="toc-text">基本数据类型之间的运算规则：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87%EF%BC%9A"><span class="toc-number">4.0.0.3.1.</span> <span class="toc-text">1.自动类型提升：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">4.0.0.3.2.</span> <span class="toc-text">2.强制类型转换：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">算数运算符：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A"><span class="toc-number">5.2.</span> <span class="toc-text">赋值运算符：&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A"><span class="toc-number">5.3.</span> <span class="toc-text">逻辑运算符：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E8%BF%90%E7%94%A8%E8%BE%83%E5%B0%91%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">位运算符（运用较少）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.5.</span> <span class="toc-text">三元运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9A"><span class="toc-number">5.6.</span> <span class="toc-text">运算符的优先级：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A4%E6%96%AD"><span class="toc-number">6.</span> <span class="toc-text">判断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if-else%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.</span> <span class="toc-text">if-else的三种结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-case%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">switch-case格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">7.</span> <span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%9A%844%E4%B8%AA%E8%A6%81%E7%B4%A0%EF%BC%9A"><span class="toc-number">7.1.</span> <span class="toc-text">循环结构的4个要素：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="toc-number">7.2.</span> <span class="toc-text">for循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-number">7.3.</span> <span class="toc-text">while循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">7.4.</span> <span class="toc-text">do-while循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%EF%BC%9A"><span class="toc-number">7.5.</span> <span class="toc-text">嵌套循环：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break%E5%92%8Ccontinue%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.6.</span> <span class="toc-text">break和continue关键字的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">8.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">数组的常见概念：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%90%8D"><span class="toc-number">8.1.1.</span> <span class="toc-text">数组名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">8.1.2.</span> <span class="toc-text">数组的特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">8.1.3.</span> <span class="toc-text">数组的分类：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">8.2.</span> <span class="toc-text">一维数组的使用：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">8.2.1.</span> <span class="toc-text">1.一维数组的声明和初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%9A%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%95%B0%E7%BB%84%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BB%8E0%E5%BC%80%E5%A7%8B%EF%BC%8C%E5%88%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6-1%E7%BB%93%E6%9D%9F"><span class="toc-number">8.2.2.</span> <span class="toc-text">2.如何调用数组的指定位置的元素：通过索引的方式，数组的索引从0开始，到数组的长度-1结束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%9A"><span class="toc-number">8.2.3.</span> <span class="toc-text">3.如何获取数组的长度：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">8.2.4.</span> <span class="toc-text">4.如何遍历数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%80%BC"><span class="toc-number">8.2.5.</span> <span class="toc-text">5.数组元素的默认初始化值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">8.3.</span> <span class="toc-text">二维数组的使用：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">8.3.1.</span> <span class="toc-text">1.二维数组的声明和初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E6%95%B0%E7%BB%84%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">8.3.2.</span> <span class="toc-text">2.如何调用数组指定位置的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">8.3.3.</span> <span class="toc-text">3.如何获取数组的长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84-1"><span class="toc-number">8.3.4.</span> <span class="toc-text">4.如何遍历数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%80%BC-1"><span class="toc-number">8.3.5.</span> <span class="toc-text">5.数组元素的默认初始化值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">8.3.5.1.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">8.4.</span> <span class="toc-text">数组中涉及的常见算法：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">面向对象：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.0.0.1.</span> <span class="toc-text">面向对象:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">9.0.0.2.</span> <span class="toc-text">面向过程：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">9.1.</span> <span class="toc-text">面向对象的三大特征：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%A6%81%E7%B4%A0%EF%BC%9A"><span class="toc-number">9.2.</span> <span class="toc-text">面向对象的两个要素：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%EF%BC%9A"><span class="toc-number">9.2.1.</span> <span class="toc-text">1.类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">9.2.2.</span> <span class="toc-text">2.对象：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E8%AE%BE%E8%AE%A1%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">9.2.2.1.</span> <span class="toc-text">*设计类其实就是设计类的成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%B0%B1%E6%98%AF%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.2.2.2.</span> <span class="toc-text">*java类的实例化就是创建类的对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">9.2.3.</span> <span class="toc-text">类中属性的使用：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">9.2.3.1.</span> <span class="toc-text">相同点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">9.2.3.2.</span> <span class="toc-text">不同点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9A"><span class="toc-number">9.2.4.</span> <span class="toc-text">默认初始化值的情况：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-number">9.2.4.1.</span> <span class="toc-text">属性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-number">9.2.4.2.</span> <span class="toc-text">局部变量：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%EF%BC%9A-1"><span class="toc-number">9.2.4.3.</span> <span class="toc-text">属性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%9A-1"><span class="toc-number">9.2.4.4.</span> <span class="toc-text">局部变量：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">9.2.5.</span> <span class="toc-text">类中方法的声明和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">9.2.5.1.</span> <span class="toc-text">方法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">9.2.6.</span> <span class="toc-text">说明：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#return%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">9.3.</span> <span class="toc-text">return关键字的使用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.4.</span> <span class="toc-text">匿名对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%88overload%EF%BC%89loading%E2%80%A6"><span class="toc-number">9.5.</span> <span class="toc-text">方法的重载（overload）loading…</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">9.5.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E5%BD%A2%E5%8F%82%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88jdk-5-0%E6%96%B0%E5%A2%9E%E5%86%85%E5%AE%B9%EF%BC%89"><span class="toc-number">9.5.2.</span> <span class="toc-text">可变个数形参的方法（jdk 5.0新增内容）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">9.5.2.1.</span> <span class="toc-text">具体使用：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E9%87%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D%EF%BC%9A%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">9.5.3.</span> <span class="toc-text">Java里方法的参数传递只有一种：值传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">9.5.3.1.</span> <span class="toc-text">值传递机制：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%BD%A2%E5%8F%82%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">9.5.3.2.</span> <span class="toc-text">方法的形参传递机制：值传递</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">9.6.</span> <span class="toc-text">了解递归方法的使用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%80%EF%BC%9A"><span class="toc-number">9.7.</span> <span class="toc-text">面向对象的特征一：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#javaBean"><span class="toc-number">9.7.1.</span> <span class="toc-text">javaBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UML%E7%B1%BB%E5%9B%BE%EF%BC%9A"><span class="toc-number">9.7.2.</span> <span class="toc-text">UML类图：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">9.8.</span> <span class="toc-text">this关键字的使用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#package%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">9.9.</span> <span class="toc-text">package关键字的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#import%EF%BC%88%E5%AF%BC%E5%85%A5%EF%BC%89%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">9.10.</span> <span class="toc-text">import（导入）关键字的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%BA%8C%EF%BC%9A"><span class="toc-number">9.11.</span> <span class="toc-text">面向对象的特征二：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%88%B0extends%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.11.1.</span> <span class="toc-text">继承性：使用到extends关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%EF%BC%88override-overwrite%EF%BC%89%EF%BC%9A"><span class="toc-number">9.11.2.</span> <span class="toc-text">重写（override&#x2F;overwrite）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">9.11.3.</span> <span class="toc-text">super关键字的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">9.12.</span> <span class="toc-text">面向对象特征之三：多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-number">9.12.1.</span> <span class="toc-text">instanceof关键字：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">9.12.2.</span> <span class="toc-text">instanceof关键字的使用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-lang-Object%E7%B1%BB"><span class="toc-number">9.13.</span> <span class="toc-text">java.lang.Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB%E4%B8%ADtoString-%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">9.13.1.</span> <span class="toc-text">Object类中toString()的使用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">9.14.</span> <span class="toc-text">Java中的JUnit单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">9.15.</span> <span class="toc-text">包装类的使用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">9.16.</span> <span class="toc-text">static关键字的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">10.1.</span> <span class="toc-text">单例设计模式：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">10.1.1.</span> <span class="toc-text">方法一：饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">10.1.2.</span> <span class="toc-text">方法二：懒汉式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%92%8C%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%9A"><span class="toc-number">10.2.</span> <span class="toc-text">区分饿汉式和懒汉式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">10.3.</span> <span class="toc-text">main()方法的使用说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">10.4.</span> <span class="toc-text">代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E8%B5%8B%E5%80%BC%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9A"><span class="toc-number">10.5.</span> <span class="toc-text">对属性可以赋值的位置：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">10.6.</span> <span class="toc-text">final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final%EF%BC%9A%E6%9C%80%E7%BB%88%E7%9A%84"><span class="toc-number">10.6.1.</span> <span class="toc-text">final：最终的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#abstract%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">10.7.</span> <span class="toc-text">abstract关键字的使用：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">11.</span> <span class="toc-text">接口：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">11.1.</span> <span class="toc-text">接口的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9A"><span class="toc-number">12.</span> <span class="toc-text">内部类：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">13.</span> <span class="toc-text">Java中常用的类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Scanner%E7%B1%BB"><span class="toc-number">13.1.</span> <span class="toc-text">Scanner类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math%E7%B1%BB"><span class="toc-number">13.2.</span> <span class="toc-text">Math类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exception%E7%B1%BB"><span class="toc-number">13.3.</span> <span class="toc-text">Exception类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E7%9B%B8%E5%85%B3%EF%BC%9A"><span class="toc-number">14.</span> <span class="toc-text">进制相关：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">15.</span> <span class="toc-text">相关注意事项：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#eclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%9A"><span class="toc-number">16.</span> <span class="toc-text">eclipse常用快捷键：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" title="前端基础">前端基础</a><time datetime="2025-09-08T09:45:43.000Z" title="发表于 2025-09-08 17:45:43">2025-09-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/02/Butterfly%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9%E9%A6%96%E9%A1%B5%EF%BC%88header%EF%BC%89/" title="Butterfly主题魔改首页添加自定义动画（header）">Butterfly主题魔改首页添加自定义动画（header）</a><time datetime="2025-09-02T15:10:27.000Z" title="发表于 2025-09-02 23:10:27">2025-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/02/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%AD/" title="Java学习笔记-续">Java学习笔记-续</a><time datetime="2025-09-02T06:12:23.000Z" title="发表于 2025-09-02 14:12:23">2025-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/02/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Java学习笔记">Java学习笔记</a><time datetime="2025-09-02T05:55:12.000Z" title="发表于 2025-09-02 13:55:12">2025-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/28/hello-world/" title="Hello World">Hello World</a><time datetime="2025-08-27T16:00:00.000Z" title="发表于 2025-08-28 00:00:00">2025-08-28</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Fire King</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="/js/custom-animation.js"</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>